This is the README for building the hybrid MPI/OpenMP or OpenMP-only parallelized versions of AutoDock 4.2 for the IBM BlueGene/P, POWER7 and intel platforms.  Automake is no longer used, what has been done instead is the target Makefile itself from running Automake has been saved and modified as the file Makefile.base.  A new master Makefile has been created for each platform:

Makefile.bgp
Makefile.power7
Makefile.intel

Call make with the -f <master Makefile> option to build the different versions of autodock.  The master makefiles are differentiated from one another through setting different variables on the command line on the call to make using the Makefile.base - you can modify those variables to match your environment and options - the DEFS and AM_CXXFLAGS variables are taken directly from the Makefile originally generated by Automake, the SELECTED_CCOMPILER and SELECTED_CPPCOMPILER variables set the name and location of the C and C++ compiler or mpiwrapper.  Read the documentation at the top of the various master makefiles for a description of the exact targets that the makefiles build - here is a sample call to build the hybrid-parallelization version using MPI and OpenMP built with the intel compiler:

make -f Makefile.intel autodock-intel-omp-mpi

Static memory footprint:
The base autodock code utilizes static data extensively - for this openmp implementation there are 2 directives that significantly influence the amount of memory taken up by static storage:

MAX_MAPS
MAX_NUM_THREADS

The 'MAX_MAPS' is the number of grid maps that need to be loaded - the default is 32.  At this value the static memory footprint is quite large.  If you know that the number of total grid maps that will be used for all dockings is less than this, then you can explicitly set this value by prepending it in the 'DEFS=' value in the make rule like this (eg you only have 12 grid maps):

-DMAX_MAPS=12

You can use the linux 'size' command to determine the amount of static storage that will be used - for example with just 1 thread and the default 32 MAX_MAPS grid maps that value is over 300mb - if you cut the MAX_MAPS in half to 16 that value becomes about 168 mb - basically each grid map takes about 8.5mb of static storage.

The other factor in the static memory requirement is the maximum number of threads you will want to run with for each individual docking.  This is set by the 'MAX_NUM_THREADS' directive and the default is 16.  Each thread takes up about 0.75 mb of static storage data structures, so for 16 threads that is an additional ~12mb of static storage.  Again you can explicitly set this value by prepending it in the 'DEFS=' value in the make rule like this (eg you want to allow 32 threads):

-DMAX_NUM_THREADS=32

So if you build without changing any values you will allow for 32 grid maps and 16 concurrent threads, your total static data size will be ~313mb (there is also additional static data unrelated to MAX_MAPS and MAX_NUM_THREADS)


To build:

- uncompress the MPAutoDock.zip file into a single directory
- add/modify the MAX_MAPS and MAX_NUM_THREADS values in the make rules if necessary
- run the make command


Performance profiling:

The MPI versions of autodock support a very detailed level of performance profiling to effectively illustrate exactly where the time is being spent in the algorithm for each individual docking.  The performance profiling can be turned on at compile time only by adding the following compiler directive to the DEFS variable inside the make rule:

-DPERF_PROFILING=1

This will enable the performance profiling which incurs very little overhead, simply remove it to turn this off.  When enabled, a csv file is updated in real time as each docking finishes, so you can effectively monitor the progress of say a virtual screen, and be made aware of any performance issues as soon as possible.  The profiling categorizes the time spent from the moment the master sends the mpi message to the slave to start the docking, to the moment the master receives the message from the slave with the status of the docking after the slave has completed it.  The csv file contains categorical performance data in a single line for each individual docking, and from this data you can monitor performance bottlenecks and easily track the progress of a virtual screen.


Running:

The non-MPI versions are invoked exactly the same as the serial version, with the addition of a -r option for the seed type (if unspecified the default_seed is used):

-r <seed_type>

The seed_type accepted values are:
same_seed - Use a hard-coded seed value, useful only in doing performance measurements by deterministically running the docking.
default_seed - Use the time of day plus the threadid for the seed.

For the OpenMP versions of autodock, there are no options on the command line for setting the number of OpenMP threads to use, just use the OMP_NUM_THREADS environment variable to specify that.

Again because of the extensive amount of static storage utilized, when running the OpenMP versions you may need to modify the amount of space allowed in the thread's stack depending on what default value your system has.  The method of doing this is specific to the OpenMP implementation - for example, autodock has been successfully tested setting the following environment variables to 10mb, but if you get errors related to the thread stack running out of memory try increasing these values:

For a gcc compiler build set: GOMP_STACKSIZE=10000
For an XL compiler build set: XLSMPOPTS=STACK=10000000
For an intel compiler build set: KMP_STACKSIZE=10000000

The MPI versions of autodock are invoked with the following 5 arguments in this precise order:

<docking_list_file> <docking_base_directory> <status_directory> <seed_type> <map_file_usage>

docking_list_file: file containing the list of ligands to be docked
docking_base_directory: base directory containing the ligand directories created with the python scripts for the virtual screening setup (eg. the 'Dockings' directory from the UsingAutoDock4forVirtualScreening_v4.pdf tutorial)
status_directory: directory containing the following status and performance logging files, updated in real time as each docking finishes:

submitted_dockings: a status line for each ligand with a timestamp of when it was sent to a slave
failed_dockings: a status line for each ligand with a timestamp of when it returned from a slave with a failure rc
successful_dockings: a status line for each ligand with a timestamp of when it returned from a slave with a successful rc
docking_performance.csv: a CSV file containing performance profiling information, the first line is  the column headers
stderrfile: stderr is redirected to this file - look here for additional error messages in the case of docking failures indicated in the 'failed_dockings' file.
stdoutfile: stdout is redirected to this file

seed_type: Indicator for the value used to seed the RNG, values must be:
same_seed - Use a hard-coded seed value, useful only in doing performance measurements.
default_seed - Use the time of day plus the threadid for the seed.
unique_node_seed - Use the time of day plus the threadid plus the mpi rank for the seed.

map_file_usage: Indicator for whether or not grid maps should persist in memory on the slave nodes from docking to docking - value must be either "reuse_maps" or "reload_maps".

Refer to the paper 'Multilevel Parallelization of AutoDock 4.2' - http://www.jcheminf.com/content/3/1/12 -  for further information for these runtime options and for details on the parallelization strategy and performnce improvements.

